Web applications are extensively deployed in Internet
services, powering a variety of functionalities, from online
shopping to social networking. These applications, irre-
spective of the underlying technology, are susceptible to
a wide range of security threats. These threats can result
in severe consequences, including data breaches, financial
The Chinese University of Hong Kong
wei @cse.cuhk.edu.hk
losses, and reputational damage [1]. Common security threats
across web applications include SQL injection [2], command
injection [3], and cross-site scripting (XSS) [4]. PHP is one
of the most popular server-side programming languages for
developing web applications, powering over 76% of web-
sites [5]. As an interpreted language, PHP offers developers
flexibility and ease of use. However, this flexibility can often
result in security vulnerabilities, making PHP applications
particularly prone to these threats.

1 a | 1 1
To mitigate these threats, security analysts have devel-
oped various techniques to detect vulnerabilities in web
applications. For instance, static analysis methods such as
TChecker [6] and RIPS [7] can scalably screen the source
code to identify suspicious security issues using predefined
heuristics. Unfortunately, they often suffer from potential
high false-positive rates, a situation that is counterproduc-
tive [8-11]. Additionally, even state-of-the-art static analysis
tools may not be able to fully model the dynamic features
of PHP, which can lead to imprecise results [6].

a: ee 1 11

a ae
Dynamic analysis methods, such as black-box scan-
ning [12-14] and grey-box fuzzing [15-19], aim to identify
vulnerabilities by executing the application and observing
its behavior. Witcher [16] leverages AFL [20] to detect SQL
injection and command injection vulnerabilities for web
applications in multiple languages. By converting semantic
errors into segmentation fault signals detectable by AFL
through customized bug oracles, it enhances the effectiveness
of detecting injection vulnerabilities. Concurrent to our work,
Atropos [18] employs a snapshot-based, feedback-driven
fuzzing method tailored for PHP-based web applications. It
introduces a feedback mechanism to automatically infer the
key-value structure at runtime. Dynamic analysis methods
typically have lower false-positive rates compared to static
analysis methods as they can observe the actual behavior of

the application, rather than relying on heuristics.
Tyr nenittn than andltrnntancenan ANmnawin mn, 4 了 alan Arwvhihki-t
Despite the advantages, dynamic methods also exhibit
significant limitations, primarily due to the intricate archi-
tecture and state-dependent nature of modern web appli-
cations [21, 22]. Modern web applications often involve
complex user interactions and maintain rich stateful behaviors
across multiple sessions and interactions. Although coverage-
guided fuzzers are designed to navigate through these states,
they inadvertently expend energy on non-critical areas instead
of focusing on truly buggy states. As a result, certain errors
that only manifest under specific states or conditions may
remain undetected. Furthermore, with the integration of
various third-party modules and libraries, ensuring thorough
coverage becomes increasingly difficult. Each additional layer
of complexity not only makes it harder to predict application
behavior but also increases the resources and time required
for effective testing. This underscores the need for developers
to complement these methods with more sophisticated testing
strategies, focusing on high-risk code locations instead of
exhaustively exploring all possible states.

NYT. .*..0. £2 DR. ge kk 1 1 tk tg 1 1
We aim to harness the strengths and mitigate the weak-
nesses of these methods. Employing directed fuzzing to
validate static analysis reports offers significant potential for
enhancing the detection of vulnerabilities in web applications.
By concentrating resources on identified high-risk targets
generated by static analysis, we can reduce the number of
states requiring exploration in dynamic testing. Directed
fuzzing can, in turn, lower the costs of manual audits
introduced by the high false-positive rates of static analysis.
Unfortunately, applying widely-used directed fuzzing tech-
niques to web applications is non-trivial, primarily because
of the characteristics inherent to the interpreted languages
used in these applications, such as PHP. For example, weak
typing and high levels of dynamism impact the precision of
static analysis, which is crucial for preparation work like
distance calculation.

A Val...’ t Frou ig] TPm 1 ， 和 1 1 1 1
Although directed fuzzing technique is well-developed
for native programs [23-29], it is not widely available for
web applications. To the best of our knowledge, Cefuzz [30]
is the only directed fuzzer for exclusively detecting remote
code execution (RCE) vulnerabilities. However, there are
several limitations to Cefuzz. 1) Cefuzz uses a coarse-grained
feedback mechanism, which fails to accurately reflect the
distance between the seed and the target. It prioritizes seeds
based on the number of reachable basic blocks (i.e., blocks
from which a path to the target exists on the control-flow
graph (CFG)) they pass through, which does not accurately
reflect the potential of the seeds. When there are multiple
paths of different lengths that can eventually reach the target
code, Cefuzz tends to give priority to the seed that takes
the longest path. 2) Cefuzz performs static instrumentation,
which increases the script length and risks altering the
behavior of the application. It inserts echo statements before
and after statements using the concatenation (i.e., new_line =
"echo(’x’);\n".old_line."echo(’y’);\n";). In such cases, if the
branch statements do not correctly use curly braces to
encapsulate the statements, it can lead to unpredictable
consequences. 3) Cefuzz is closed-source, which limits its
aNd alter slatCMents Usille ule CONCAtendauON W.e., new_line =
"echo(’x’);\n".old_line."echo(’y’);\n";). In such cases, if the
branch statements do not correctly use curly braces to
encapsulate the statements, it can lead to unpredictable
consequences. 3) Cefuzz is closed-source, which limits its
further development and usability.
In this paper, we propose PREDATOR, an efficient di-
rected fuzzing tool for web applications. By selectively
instrumenting the web application at runtime, PREDATOR
stores inter-procedural block distances without altering the
source code. The distance feedback prioritizes in test cases
that are closer to predefined high-risk code locations, thereby
avoiding inefficient random state exploration. Moreover,
PREDATOR updates the block distances at runtime to correct
the imprecise static analysis results and enable exploring
more promising paths. PREDATOR employs novel tailored
mutation strategies for web applications, which are guided by
distance and parameters. It probabilistically adopts different
mutation strategies based on the current input distance
to enhance effectiveness in both exploration and exploita-
tion stages. By employing parameter-to-condition analysis,
PREDATOR concentrates mutations on a group of parameters
involved in condition expressions, targeting deeper areas that
current fuzzers struggle to reach.
To evaluate the effectiveness and efficiency of
PREDATOR, we conducted a comprehensive assessment on
both synthetic and real-world web applications, covering
a wide range of vulnerabilities. Compared to state-of-the-
art fuzzers, PREDATOR detected more vulnerabilities and
triggered them up to 43.8 times faster. We demonstrated that
each component of PREDATOR contributed to the overall
performance. We showcased the effectiveness of PREDATOR
in validating static analysis reports and reducing the manual
auditing efforts. When applying PREDATOR to detect new
vulnerabilities, we identified 26 previously unknown vulnera-
bilities in real-world web applications, 7 of which have been
acknowledged and patched.

nae naa