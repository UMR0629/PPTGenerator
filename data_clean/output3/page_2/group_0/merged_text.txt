across multiple sessions and interactions. Although coverage-
guided fuzzers are designed to navigate through these states,
they inadvertently expend energy on non-critical areas instead
of focusing on truly buggy states. As a result, certain errors
that only manifest under specific states or conditions may
remain undetected. Furthermore, with the integration of
various third-party modules and libraries, ensuring thorough
coverage becomes increasingly difficult. Each additional layer
of complexity not only makes it harder to predict application
behavior but also increases the resources and time required
for effective testing. This underscores the need for developers
to complement these methods with more sophisticated testing
strategies, focusing on high-risk code locations instead of
exhaustively exploring all possible states.

NYT. .*..0. £2 DR. ge kk 1 1 tk tg 1 1
We aim to harness the strengths and mitigate the weak-
nesses of these methods. Employing directed fuzzing to
validate static analysis reports offers significant potential for
enhancing the detection of vulnerabilities in web applications.
By concentrating resources on identified high-risk targets
generated by static analysis, we can reduce the number of
states requiring exploration in dynamic testing. Directed
fuzzing can, in turn, lower the costs of manual audits
introduced by the high false-positive rates of static analysis.
Unfortunately, applying widely-used directed fuzzing tech-
niques to web applications is non-trivial, primarily because
of the characteristics inherent to the interpreted languages
used in these applications, such as PHP. For example, weak
typing and high levels of dynamism impact the precision of
static analysis, which is crucial for preparation work like
distance calculation.

A Val...’ t Frou ig] TPm 1 ， 和 1 1 1 1
Although directed fuzzing technique is well-developed
for native programs [23-29], it is not widely available for
web applications. To the best of our knowledge, Cefuzz [30]
is the only directed fuzzer for exclusively detecting remote
code execution (RCE) vulnerabilities. However, there are
several limitations to Cefuzz. 1) Cefuzz uses a coarse-grained
feedback mechanism, which fails to accurately reflect the
distance between the seed and the target. It prioritizes seeds
based on the number of reachable basic blocks (i.e., blocks
from which a path to the target exists on the control-flow
graph (CFG)) they pass through, which does not accurately
reflect the potential of the seeds. When there are multiple
paths of different lengths that can eventually reach the target
code, Cefuzz tends to give priority to the seed that takes
the longest path. 2) Cefuzz performs static instrumentation,
which increases the script length and risks altering the
behavior of the application. It inserts echo statements before
and after statements using the concatenation (i.e., new_line =
"echo(’x’);\n".old_line."echo(’y’);\n";). In such cases, if the
branch statements do not correctly use curly braces to
encapsulate the statements, it can lead to unpredictable
consequences. 3) Cefuzz is closed-source, which limits its
aNd alter slatCMents Usille ule CONCAtendauON W.e., new_line =
"echo(’x’);\n".old_line."echo(’y’);\n";). In such cases, if the
branch statements do not correctly use curly braces to
encapsulate the statements, it can lead to unpredictable
consequences. 3) Cefuzz is closed-source, which limits its
further development and usability.
In this paper, we propose PREDATOR, an efficient di-
rected fuzzing tool for web applications. By selectively
instrumenting the web application at runtime, PREDATOR
stores inter-procedural block distances without altering the
source code. The distance feedback prioritizes in test cases
that are closer to predefined high-risk code locations, thereby
avoiding inefficient random state exploration. Moreover,
PREDATOR updates the block distances at runtime to correct
the imprecise static analysis results and enable exploring
more promising paths. PREDATOR employs novel tailored
mutation strategies for web applications, which are guided by
distance and parameters. It probabilistically adopts different
mutation strategies based on the current input distance
to enhance effectiveness in both exploration and exploita-
tion stages. By employing parameter-to-condition analysis,
PREDATOR concentrates mutations on a group of parameters
involved in condition expressions, targeting deeper areas that
current fuzzers struggle to reach.
To evaluate the effectiveness and efficiency of
PREDATOR, we conducted a comprehensive assessment on
both synthetic and real-world web applications, covering
a wide range of vulnerabilities. Compared to state-of-the-
art fuzzers, PREDATOR detected more vulnerabilities and
triggered them up to 43.8 times faster. We demonstrated that
each component of PREDATOR contributed to the overall
performance. We showcased the effectiveness of PREDATOR
in validating static analysis reports and reducing the manual
auditing efforts. When applying PREDATOR to detect new
vulnerabilities, we identified 26 previously unknown vulnera-
bilities in real-world web applications, 7 of which have been
acknowledged and patched.

nae naa